" ----------------------------------------------------------------------
" Instantiate pathogen to install plugins
" ----------------------------------------------------------------------
call pathogen#infect()

" ----------------------------------------------------------------------
"  Terminal
" ----------------------------------------------------------------------
if &term == 'xterm-256color'
    set t_Co=256
elseif &term == 'rxvt-unicode'
    set t_Co=88
else
    set t_Co=16
endif

" ----------------------------------------------------------------------
" Make it play nicely with tmux
" ----------------------------------------------------------------------
map <Esc>[A <Down>

" ----------------------------------------------------------------------
" Option specific for gvim
" ----------------------------------------------------------------------
if has("gui_running")
    " set gfn=Consolas\ 11   " default font
    " set gfn=Envy\ Code\ R\ 10
    " set gfn=Envy\ Code\ R\ for\ Powerline
    set gfn=Droid\ Sans\ Mono\ Dotted\ for\ Powerline\ 9
    set lsp=1              " number of pixels between line
    set guioptions-=T      " disable toolbard
    set guioptions-=r      " disable scrollbar
    set lines=60           " window height
    set columns=120        " window width
    set guicursor+=a:blinkon0  " stop blinking
    set go-=L
    set go-=T
    highlight Normal guibg=black guifg=white

    " Shift-Insert to copy clipboard to gvim
    set guioptions+=a
    nmap <S-Insert> "+gP
    imap <S-Insert> <ESC><S-Insert>i
endif

" ----------------------------------------------------------------------
" Faster switch between insert and command mode for terminal
" ----------------------------------------------------------------------
if ! has('gui_running')
    set ttimeoutlen=10
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif

if &term =~ '^xterm'
  " solid underscore in insert mode
  let &t_SI .= "\<Esc>[4 q"
  " solid block in any other mode
  let &t_EI .= "\<Esc>[2 q"
  " 1 or 0 -> blinking block
  " 3 -> blinking underscore
  " 4 -> solid underscore
  " reset cursor when vim exits
  autocmd VimLeave * silent !echo -ne "\033]112\007"
endif

" ----------------------------------------------------------------------
" keep the swap file here.
" ----------------------------------------------------------------------
if has("win32") || has("win64")
    set directory=$TMP
else
    set directory=/tmp
end

" ----------------------------------------------------------------------
"  Use Python Powerline
"  Install it using: pip install https://github.com/Lokaltog/powerline/tarball/develop
"  Disable laststatus/statusline in favor of powerline
" ----------------------------------------------------------------------
" set statusline=[%n]\ [FORMAT=%{&ff}]\ %<%.99f\ %h%w%m%r%y\ \ \ [%{Tlist_Get_Tagname_By_Line()}]\ %=%-16(\ %l,%c-%v\ %)%P\ [ASCII=\%03.3b]\ [HEX=\%02.2B]
set laststatus=2                      " Status bar
" python from powerline.ext.vim import source_plugin; source_plugin()
" set rtp+=/home/et6339/cvs/vim-plugins/powerline/powerline/bindings/vim
" set fillchars+=stl:\ ,stlnc:\

" ----------------------------------------------------------------------
" Use vim.powerline as the Python version is not mature yet
" ----------------------------------------------------------------------
if has("gui_running")
    let g:Powerline_symbols = 'fancy'
else
    let g:Powerline_symbols = 'unicode'
endif

" ----------------------------------------------------------------------
"  Default setting
" ----------------------------------------------------------------------
set nocompatible                        " use Vim defaults (much better!)
set nostartofline                       " keep cursor in the same column (useful for selecting column)
set hidden                              " Allow to open a new buffer without saving current one
let mapleader=","
set encoding=utf-8
set tenc=utf-8
setglobal fenc=utf-8
set wildignore+=*CVS,*/tmp/*,*.so,*.swp,*.zip
set textwidth=120
set tabstop=4
set shiftwidth=4
set shiftround                          " Always indent to the nearest tabstop
set smarttab                            " Use shiftwidths at left margin, tabstops everywhere else
set formatoptions=tcq2
set formatoptions-=cro
set wrapmargin=2                        " Wrap 2 characters from the edge of the window
set ruler                               " display cursor position on the bottom right
set nolist
set bs=2                                " allow backspacing over everything in insert mode
set smartindent
set ai                                  " always set autoindenting on
set viminfo='20,\"50                    " read/write a .viminfo file, don't store more than 50 lines of registers
set showmode                            " show current mode?
set showcmd                             " show currently type command?
set scrolloff=5                         " 5 lines before and after cursor on top/bottom screen
set mouse=a                             " mouse selection don't include number list
set selectmode=mouse
set undolevels=50
set modelines=0
set ttyfast
set relativenumber                      " only in 7.3+ - show relative line number from previous line
set undofile                            " only in 7.3+ - create filename.un~ so that we can undo it even after we close and reopen it
" set backup                            " not needed, done it via undofile above
" set backupext=.backup                 " will be named with an extension of .backup
syntax on
syn sync fromstart

" Don't start with an empty extra buffer on startup
if bufname('%') == ''
  set bufhidden=wipe
endif

" ----------------------------------------------------------------------
" [ Improve move speed ]
" ----------------------------------------------------------------------
set cursorcolumn
set cursorline
let g:boostmove=0
set updatetime=500
au CursorMoved * call BoostMoveON()
au CursorMovedI * call BoostMoveON()
au CursorHold * call BoostMoveOFF()
au CursorHoldI * call BoostMoveOFF()

function BoostMoveON()
    if (winline() != line('$')) && (line('.') != 1)
        if (winline() == winheight('.')) || (winline() == 1)
            let g:boostmove=1
            setlocal nocursorline
            setlocal syntax=OFF
        endif
    endif
endfunction

function BoostMoveOFF()
    if g:boostmove==1
        let g:boostmove=0
        setlocal cursorline
        setlocal syntax=ON
    endif
endfunction

" ----------------------------------------------------------------------
" [ Toggle visibility of naughty characters ]
" ----------------------------------------------------------------------

" Make naughty characters visible...
" (uBB is right double angle, uB7 id middle dot)
exec "set lcs=tab:\uBB\uBB,trail:\uB7,nbsp:~"

augroup VisibleNaughtiness
    au!
    au BufEnter * set list
    au BufEnter *.txt set nolist
    au BufEnter *.vp* set nolist
augroup END

" ----------------------------------------------------------------------
" [ Set up smarter search behaviour ]
" ----------------------------------------------------------------------
set incsearch  " Lookahead as search pattern specified
set ignorecase " Ignore case in all searches...
set smartcase  "...unless uppercase letters used
set hlsearch   " Highlight all search matches
set gdefault   " Change globally in the same line
set showmatch  " show matching parens?

" ----------------------------------------------------------------------
" [ Center the display line after searches. (This makes it *much* easier to see
"   the matched line) ]
"
" More info: http://www.vim.org/tips/tip.php?tip_id=528
" ----------------------------------------------------------------------
nnoremap n nzz
nnoremap N Nzz
nnoremap * *zz
nnoremap # #zz
nnoremap g* g*zz
nnoremap g# g#zz

" ----------------------------------------------------------------------
"  Fix vim broken regex by automatically inserting a \v before any string
" ----------------------------------------------------------------------
nnoremap / /\v
vnoremap / /\v

" ----------------------------------------------------------------------
" [ There can be only one (one Vim session per file) ]
" ----------------------------------------------------------------------

augroup NoSimultaneousEdits
    au!
    au SwapExists * let v:swapchoice = 'o'
    au SwapExists * echohl ErrorMsg
    au SwapExists * echo 'Duplicate edit session (readonly)'
    au SwapExists * echohl None
    au SwapExists * sleep 2
augroup END


" ----------------------------------------------------------------------
" For performance -- automatic foldmethod makes vim very slow to autocomplete
" Sourced from vim tip: http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text
"
autocmd InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif
set complete-=i    " Disable searching for include files, boost performance

" ----------------------------------------------------------------------
"  PLUGIN: xml.vim - unfortunately it needs to be declared prior to filetype plugin on below.
" ----------------------------------------------------------------------
let xml_use_xhtml = 1

" ----------------------------------------------------------------------
" ACK integration for grep
" ----------------------------------------------------------------------
" set grepprg=ack
" set grepformat=%f:%l:%m

" ----------------------------------------------------------------------
" Set default value for letter capital-K
" ----------------------------------------------------------------------
au BufReadPost *.pl   set keywordprg=perldoc\ -f
au BufReadPost *.pm   set keywordprg=perldoc\ -f
au BufReadPost *.vim  map K :exe ":help ".expand("<cword>")<CR>
au BufReadPost .vimrc map K :exe ":help ".expand("<cword>")<CR>

" ----------------------------------------------------------------------
" [ Make Visual modes work better ]
" ----------------------------------------------------------------------

" Visual Block mode is far more useful that Visual mode (so swap the commands)...
nnoremap v <C-V>
nnoremap <C-V> v

vnoremap v <C-V>
vnoremap <C-V> v

" Make BS/DEL work as expected in visual modes (i.e. delete elected)...
vmap <BS> x

"Square up visual selections...
set virtualedit=block

" ----------------------------------------------------------------------
" Retain visual block after indenting
" ----------------------------------------------------------------------

" When shifting, retain selection over multiple shifts...
vmap <expr> > KeepVisualSelection(">")
vmap <expr> < KeepVisualSelection("<")

function! KeepVisualSelection(cmd)
    set nosmartindent
    if mode() ==# "V"
        return a:cmd . ":set smartindent\<CR>gv"
    else
        return a:cmd . ":set smartindent\<CR>"
    endif
endfunction


" ========[ Disabled, replace with below function which is easier to eye ]===============
" highlight lines longer than 120 chars in perl files 
" autocmd FileType perl match ErrorMsg '\%>120v.\+'

"====[ Make the 81st column stand out ]====================
highlight ColorColumn ctermbg=magenta
call matchadd('ColorColumn', '\%121v', 100)

" set execute bit
autocmd BufWritePost *.pl,*.ksh,*.sh,*.bash !chmod +x %

"=====[ Highlight matches when jumping to next ]=============
nnoremap <silent> n n:call HLNext(0.4)<cr>
nnoremap <silent> N N:call HLNext(0.4)<cr>

"=====[ Highlight the match in red ]=============
function! HLNext (blinktime)
    highlight WhiteOnRed ctermfg=white ctermbg=red
    let [bufnum, lnum, col, off] = getpos('.')
    let matchlen = strlen(matchstr(strpart(getline('.'),col-1),@/))
    let target_pat = '\c\%#'.@/
    let ring = matchadd('WhiteOnRed', target_pat, 101)
    redraw
    exec 'sleep ' . float2nr(a:blinktime * 1000) . 'm'
    call matchdelete(ring)
    redraw
endfunction

"======[ colorfull diff ]=============
augroup PatchDiffHighlight
    autocmd!
    autocmd FileType diff syntax enable
augroup END

"======[ listtrans.vim plugin from Damian Conway ]=========================
nmap ;l :call ListTrans_toggle_format()<CR>
vmap ;l :call ListTrans_toggle_format('visual')<CR>

"======[ vmath.vim plugin from Damian Conway ]==========================
vmap <expr> ++ VMATH_YankAndAnalyse()
nmap        ++ vip++

"=====[ Column indicator when inserting in visual mode ]====================
" Temporarily add a column indicator when inserting or appending in visual mode...
" (Should use <C-O> instead, but it doesn't seem to work)
vnoremap <silent>  I  I<C-R>=TemporaryColumnMarkerOn()<CR>
vnoremap <silent>  A  A<C-R>=TemporaryColumnMarkerOn()<CR>

function! TemporaryColumnMarkerOn ()
    let g:prev_cursorcolumn_state = g:cursorcolumn_visible ? 'on' : 'off'
    call Toggle_CursorColumn('on')
    inoremap <silent>  <ESC>  <ESC>:call TemporaryColumnMarkerOff(g:prev_cursorcolumn_state)<CR>
    return ""
endfunction

function! TemporaryColumnMarkerOff (newstate)
    call Toggle_CursorColumn(a:newstate)
    iunmap <ESC>
endfunction

" Implement cursor toggle...
let g:cursorcolumn_visible = 0
function! Toggle_CursorColumn (requested_state)
    if a:requested_state == 'off' || g:cursorcolumn_visible && a:requested_state == 'flip'
        let g:cursorcolumn_visible = 0
        highlight clear CursorColumn
        highlight CursorColumn term=none cterm=none
    else
        let g:cursorcolumn_visible = 1
        highlight CursorColumn term=bold ctermfg=233 ctermbg=109 cterm=bold
    endif
endfunction

"=====[ Show help files in a new tab, plus add a shortcut for helpg ]==============
"Only apply to .txt files...
augroup HelpInTabs
    autocmd!
    autocmd BufEnter  *.txt   call HelpInNewTab()
augroup END

"Only apply to help files...
function! HelpInNewTab ()
    if &buftype == 'help'
        "Convert the help window to a tab...
        execute "normal \<C-W>T"
    endif
endfunction

"=====[ plugin dragvisuals.vim from Damian Conway ]=========================
" Unfortunately left and right do not work for me...
" vmap <expr> <LEFT> DVB_Drag('left')
" vmap <expr> <RIGHT> DVB_Drag('right')
vmap <expr> <DOWN> DVB_Drag('down')
vmap <expr> <UP> DVB_Drag('up')

"Duplicator block
vmap <expr> D DVB_Duplicate()

" ----------------------------------------------------------------------
"  Perl specific
" ----------------------------------------------------------------------

" let perl_nofold_packages=1
let perl_fold=1
let perl_fold_blocks=1
set foldlevelstart=999999           " don't start folding at startup
let perl_want_scope_in_variables=1
let perl_extended_vars=1
let perl_include_pod=1
let perl_sync_dist=250

" =====[ Handle Perl include files better ]===========
set include=^\\s*use\\s\\+\\zs\\k\\+\\ze
set includeexpr=substitute(v:fname,'::','/','g')
set suffixesadd=.pm
execute 'set path+=' . substitute($PERL5LIB, ':', ',', 'g')

" Run perltidy in normal and visual mode
nnoremap ,pt  :%!perltidy -q<cr> " only work in 'normal' mode
vnoremap ,pt  :!perltidy -q<cr>  " only work in 'visual' mode

" perlcritic
noremap ,pc :!time perlc --critic %<cr>

" Extract long subroutine into inner sub
vnoremap ,ext :!~/files/bin/extract_sub <cr>

" Adjust keyword characters for Perlish identifiers...
set iskeyword+=$
set iskeyword+=%
set iskeyword+=@
set iskeyword+=:
set iskeyword-=,

" Execute Perl file (output to pager)...
if has("gui_running")
    nmap E :!/usr/bin/xterm -hold -e /bin/bash -l -c "perl -MDebug::Phases -w %"<CR>
else
    nmap E :!mperl -w %<CR>
endif

" run perl syntac check on save
au FileType perl set makeprg=perl\ -c\ %\ $*

" =====[ quickfix for Perl error formats ]=============
set errorformat+=%m\ at\ %f\ line\ %l\.
set errorformat+=%m\ at\ %f\ line\ %l

" comment this line as it makes vim runs very slow 
" au FileType perl set errorformat=%f:%l:%m

" =====[ Auto-setup for Perl scripts and modules ]===========
augroup Perl_Setup
    au!
    au BufNewFile *.p[lm] 0r !file_template <afile>
    au BufNewFile *.p[lm] /^[ \t]*[#].*implementation[ \t]\+here/
augroup END

" ----------------------------------------------------------------------
"  PerlOmni
" ----------------------------------------------------------------------
let g:omni_syntax_group_exclude_perl = 'perlPOD'    " disable POD on omni completion
let g:perlomni_export_functions = 1

" local set in perlomni.vim plugin does not work as expected..set globally
set omnifunc=PerlComplete

" ----------------------------------------------------------------------
" perldoc2.vim (colorize perldoc)
" ----------------------------------------------------------------------
let g:Perldoc_path='/tmp/'
map <F8> :Perldoc<CR>


" ----------------------------------------------------------------------
" golang (Go) specific
" ----------------------------------------------------------------------
" =====[ go fmt ]===========
function! GoFmt()
    try                
        exe "undojoin"
        exe "Fmt"
    catch              
    endtry
endfunction

au BufRead,BufNewFile *.go setlocal ft=go ts=4 sw=4 expandtab
let g:gofmt_command='gofmt -tabs=false -tabwidth=4'
au FileType go au BufWritePre <buffer> call GoFmt()

" ----------------------------------------------------------------------
" expandtab is commented out below as we want to set it only on specific
" FileType via SetCodingStyle()
" ----------------------------------------------------------------------
" set expandtab

" ----------------------------------------------------------------------
" Workaround for Cygwin
" ----------------------------------------------------------------------
" let g:netrw_cygwin=1
" let g:netrw_scp_cmd="/usr/bin/scp"
" let g:netrw_liststyle=3
" let g:netrw_browse_split=4
" set t_ti= t_te=

" ----------------------------------------------------------------------
" [ Miscellaneous features (mainly options) ]
" ----------------------------------------------------------------------

set nomore      " Don't page long listings
set autowrite   " Save buffer automatically when changing files
set autoread    " Always reload buffer when external changes detected

"           +--Disable hlsearch while loading viminfo
"           |  +--Remember marks for last 50 files
"           |  |      +--Remember up to 1000 lines in each register
"           |  |      |   +--Remember up to 1MB in each register
"           |  |      |   |      +--Remember last 1000 search patterns
"           |  |      |   |      |    +---Remember last 100 commands
"           |  |      |   |      |    |
"           v  v      v   v      v    v
set viminfo=h,'50,<10000,s1000,/1000,:100

set backspace=indent,eol,start    " BS past autoindents, line boundaries,
                                  " and even the start of insertion

set fileformats=unix,mac,dos      " Handle Mac and DOS line-endings
                                  " but prefer Unix endings

set wildmode=list:longest,full    " Show list of completions
                                " and complete as much as possible then iterate full completions

set noshowmode                    " Suppress mode change messages

" Use space to jump down a page (like browsers do)...
nnoremap <Space> <PageDown>

" ######################################################################
"                            Plugins
" ######################################################################

" ----------------------------------------------------------------------
"  TabBar config
" ----------------------------------------------------------------------
"  Note: comment out the following two TabBar settings in preference of vim-airline
" let g:Tb_SplitBelow=1       " Put the tabbar at the bottom
let g:Tb_MoreThanOne = 9999   " Never shows TabBar, just use its Tbbp & Tbbn functions. The buffers list is shown by BufferLine
let g:Tb_ModSelTarget = 1
noremap <C-PageUp>   :Tbbp<CR>  
noremap <C-PageDown> :Tbbn<CR>

" ----------------------------------------------------------------------
"  BufferLine
" ----------------------------------------------------------------------
let g:bufferline_echo = 0

" use fancy buffer closing that doesn't close the split
cnoremap <expr> bd (getcmdtype() == ':' ? 'Bclose' : 'bd') 
let bclose_multiple = 1

" ----------------------------------------------------------------------
" NERD_Tree config
" ----------------------------------------------------------------------
let NERDTreeShowLineNumbers=0
let NERDTreeShowBookmarks=0
let NERDTreeChDirMode=2
let NERDTreeIgnore=['CVS']
let NERDTreeWinPos="left"
let NERDTreeWinSize=35
let NERDTreeDirArrows=1
let NERDChristmasTree=1
" let g:nerdtree_tabs_open_on_console_startup = 1    " open NERDTree on console vim startup
let g:nerdtree_tabs_open_on_gui_startup=0
map <F10> :NERDTreeTabsToggle<CR>

"autocmd vimenter * NERDTree
"autocmd vimenter * if !argc() | NERDTree | endif
"autocmd vimenter * wincmd w
"autocmd BufEnter * NERDTreeMirror

" ----------------------------------------------------------------------
" tasklisk plugin (TODO, FIXME, XXX, etc)
" ----------------------------------------------------------------------
let g:tlWindowPosition = 1
let g:tlTokenList = ['FIXME:', 'TODO:', 'XXX:', 'TANED:']
map T :TaskList<CR>
map <leader>tl <Plug>TaskList

" ----------------------------------------------------------------------
"  Tagbar and/or Taglist (tag for subroutine, method, class, etc)
" ----------------------------------------------------------------------
set tags=./tags,tags,/tmp/tags
nnoremap <silent> <F9> :TagbarToggle<CR>

" =====[ Perl5 and tagbar ]===========
let g:tagbar_type_perl     = {
    \ 'ctagstype': 'perl',
    \ 'kinds': [
        \'b:blocks',
        \'p:packages:0:1',
        \'c:constants',
        \'f:formats',
        \'l:labels',
        \'s:subroutines',
        \'u:modules:1',
        \'r:requires',
        \'z:attribute',
        \'a:aliases',
        \'o:global variables:1',
        \'d:POD',
        \'w:Roles',
        \'e:Extends',
    \]
\}

" =====[ gotags and tagbar ]===========
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }


" ----------------------------------------------------------------------
"  vim-airline 
" ----------------------------------------------------------------------
let g:airline_powerline_fonts = 1                " use font from vim-powerline
let g:airline#extensions#tabline#enabled = 1     " display all buffers when there is only 1 tab open


" ----------------------------------------------------------------------
"  CTRLP - fuzzy finder
" ----------------------------------------------------------------------
set runtimepath^=~/.vim/bundle/ctrlp.vim
let g:ctrlp_max_height = 30    " maximum height of the match window


" ----------------------------------------------------------------------
" ABBREVIATIONS
" ----------------------------------------------------------------------
:ab Yruler #23456789\|123456789\|123456789\|123456789\|123456789\|123456789\|12345678\|0123456789\|123456789\|123456789\|
iab Ydated  <C-R>=strftime("%a %d-%m-%Y")<CR>
iab Ydatet  <C-R>=strftime("%Y%m%d %T")<CR>
iab Yfilepath   <C-R>=getcwd()."/".bufname(1)<CR>

"=====[ Correct common mistypings in-the-fly ]=======================

iab retrun return
iab pritn print
iab teh the
iab liek like
iab liekwise likewise
iab Pelr Perl
iab pelr perl
iab ;t 't
iab moer more
iab previosu previous

" ----------------------------------------------------------------------
" Mappings
" ----------------------------------------------------------------------
" added dash underline by CTRL-H
nnoremap <Leader>H yyp^v$r-<Esc>jA

" ----------------------------------------------------------------------
" Moving between open window
" ----------------------------------------------------------------------
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l


" ----------------------------------------------------------------------
"  FUNCTIONS
" ----------------------------------------------------------------------

" function to set coding style
:function SetCodingStyle()
:  set tabstop=4
:  set expandtab
:endfunction

" HTML file
:function SetHtmlStyle()
:  set tabstop=4
:  set expandtab
:  set textwidth=0
:endfunction

" Highlight a column in csv text.
" :Csv 1    " highlight first column
" :Csv 12   " highlight twelfth column
" :Csv 0    " switch off highlight
function! CSVH(colnr)
  if a:colnr > 1
    let n = a:colnr - 1
    execute 'match Keyword /^\([^,]*,\)\{'.n.'}\zs[^,]*/'
    execute 'normal! 0'.n.'f,'
  elseif a:colnr == 1
    match Keyword /^[^,]*/
    normal! 0
  else
    match
  endif
endfunction
command! -nargs=1 Csv :call CSVH(<args>)

" ----------------------------------------------------------------------
"  [ Substitute the file to scp://host/dir/file for remote ctags ]
"    :Rct 'mbk10','workdir'
"    :Rct 'vcmsd','cvs/centrelink.solutions/bin'
" ----------------------------------------------------------------------
function! Remotectags(hosts,dirs)
    let host = a:hosts
    let dir = a:dirs
    execute '%s#^\(\w\+\)\t#\1\tscp://' . host . '/' . dir . '/#'
endfunction
command! -nargs=+ Rct :call Remotectags(<args>)

" ----------------------------------------------------------------------
"  [ Remove trailing spaces automatically ]
" ----------------------------------------------------------------------
function! Preserve(command)
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Do the business:
  execute a:command
  " Clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction
nmap _$ :call Preserve("%s/\\s\\+$//e")<CR>
nmap _= :call Preserve("normal gg=G")<CR>


" ----------------------------------------------------------------------
" [ Convert file to different tabspacings ]
" ----------------------------------------------------------------------
function! InferTabspacing ()
    return min(filter(map(getline(1,'$'),'strlen(matchstr(v:val, ''^\s\+''))'),'v:val != 0'))
endfunction

function! NewTabSpacing (newtabsize)
    " Determine apparent tabspacing, if necessary...
    if &tabstop == 4
        let &tabstop = InferTabspacing()
    endif

    " Preserve expansion, if expanding...
    let was_expanded = &expandtab

    " But convert to tabs initially...
    normal TT

    " Change the tabsizing...
    execute "set ts="  . a:newtabsize
    execute "set sw="  . a:newtabsize

    " Update the formatting commands to mirror than new tabspacing...
    execute "map          F !Gformat -T" . a:newtabsize . " -"
    execute "map <silent> f !Gformat -T" . a:newtabsize . "<CR>"

    " Re-expand, if appropriate...
    if was_expanded
        normal TS
    endif
endfunction

" Note, these are all T-<SHIFTED-DIGIT>, which is easier to type...
map <silent> T@ :call NewTabSpacing(2)<CR>
map <silent> T# :call NewTabSpacing(3)<CR>
map <silent> T$ :call NewTabSpacing(4)<CR>
map <silent> T% :call NewTabSpacing(5)<CR>
map <silent> T^ :call NewTabSpacing(6)<CR>
map <silent> T& :call NewTabSpacing(7)<CR>
map <silent> T* :call NewTabSpacing(8)<CR>

" Convert to/from spaces/tabs...
map <silent> TS :set expandtab<CR>:%retab!<CR>
map <silent> TT :set noexpandtab<CR>:%retab!<CR>

" ----------------------------------------------------------------------
"  Comment
" ----------------------------------------------------------------------
inoremap # X<C-H>#|                            " And no magic outdent for comments
nnoremap <silent> >> :call ShiftLine()<CR>|    " And no shift magic on comments

function! ShiftLine()
    set nosmartindent
    normal! >>
    set smartindent
endfunction


"=====[ Add or subtract comments ]===============================

" Work out what the comment character is, by filetype...
autocmd BufNewFile,BufRead   *                                 let b:cmt = exists('b:cmt') ? b:cmt : ''
autocmd FileType             *sh,awk,python,perl,perl6,ruby    let b:cmt = exists('b:cmt') ? b:cmt : '# '
autocmd FileType             vim                               let b:cmt = exists('b:cmt') ? b:cmt : '" '

" Work out whether the line has a comment then reverse that condition...
function! ToggleComment ()
    " What's the comment character???
    let comment_char = exists('b:cmt') ? b:cmt : '# '

    " Grab the line and work out whether it's commented...
    let currline = getline(".")

    " If so, remove it and rewrite the line...
    if currline =~ '^' . comment_char
        let repline = substitute(currline, '^' . comment_char, "", "")
        call setline(".", repline)

    " Otherwise, insert it...
    else
        let repline = substitute(currline, '^', comment_char, "")
        call setline(".", repline)
    endif
endfunction

" Toggle comments down an entire visual selection of lines...
function! ToggleBlock () range
    " What's the comment character???
    let comment_char = exists('b:cmt') ? b:cmt : '# '

    " Start at the first line...
    let linenum = a:firstline

    " Get all the lines, and decide their comment state by examining the first...
    let currline = getline(a:firstline, a:lastline)
    if currline[0] =~ '^' . comment_char
        " If the first line is commented, decomment all...
        for line in currline
            let repline = substitute(line, '^' . comment_char, "", "")
            call setline(linenum, repline)
            let linenum += 1
        endfor
    else
        " Otherwise, encomment all...
        for line in currline
            let repline = substitute(line, '^\('. comment_char . '\)\?', comment_char, "")
            call setline(linenum, repline)
            let linenum += 1
        endfor
    endif
endfunction

" Set up the relevant mappings
nmap <silent> # :call ToggleComment()<CR>j0
vmap <silent> # :call ToggleBlock()<CR>

" ----------------------------------------------------------------------
"  AUTOCOMMAND for each file type
" ----------------------------------------------------------------------
autocmd FileType sh call SetCodingStyle()
autocmd FileType perl call SetCodingStyle()
au FileType perl,sh,php set cin cinkeys=0{,0},:,!^F,o,O,e comments=s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-
autocmd FileType html call SetHtmlStyle()
autocmd FileType chtml call SetHtmlStyle()
autocmd FileType schtml call SetHtmlStyle()
autocmd FileType js call SetCodingStyle()
autocmd FileType css call SetCodingStyle()
autocmd BufRead todo.html set ts=8 tw=120
autocmd BufRead /tmp/cvs set ts=8 et tw=120
autocmd FileType perl,html,chtml,schtml,js,c set number
autocmd Filetype perl setlocal omnifunc=syntaxcomplete#Complete

" .(s)chtml file
autocmd BufNewFile,BufRead *.inc setf html
autocmd BufNewFile,BufRead *.chtml setf html
autocmd BufNewFile,BufRead *.schtml setf html

" In text files, always limit the width of text to 78 characters
autocmd BufRead *.txt set tw=120

" In email files, always limit the width of text to 64 characters
autocmd BufRead mutt-* set tw=120

autocmd BufRead *.frm set expandtab ts=8
autocmd BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif

" ----------------------------------------------------------------------
"  Additional colours
" ----------------------------------------------------------------------
set background=dark
hi Comment term=NONE ctermfg=DarkCyan
highlight constant ctermfg=DarkGreen

" Color scheme must be the last line
" colorscheme ir_black2
colorscheme kraihlight

" ----------------------------------------------------------------------
" [Make the completion popup look menu-ish on a Mac]
" ----------------------------------------------------------------------
highlight Pmenu guibg=white guifg=black gui=NONE ctermbg=white ctermfg=black
highlight PmenuSel guibg=#899ab4 guifg=white gui=BOLD ctermbg=blue ctermfg=white cterm=bold
highlight PmenuSbar guibg=grey guifg=grey gui=NONE ctermbg=grey ctermfg=grey
highlight PmenuThumb guibg=#899ab4 guifg=#899ab4 gui=NONE ctermbg=blue ctermfg=blue

" ----------------------------------------------------------------------
"  [file type must be the last lines so that all plugins work]
" ----------------------------------------------------------------------
filetype on
filetype plugin on
filetype indent on
